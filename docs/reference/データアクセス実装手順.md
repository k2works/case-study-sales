```plantuml
@startmindmap
* データアクセス
-- 自動生成
--- MyBatisモデル
---- 売上データ
---- 売上データ明細
---- 自動採番マスタ
--- MyBatisマッパー
---- 売上データMapper
---- 売上データ明細Mapper
---- 自動採番マスタMapper
-- カスタム拡張
--- カスタムエンティティ
---- SalesCustomEntity
---- SalesLineCustomEntity
--- カスタムマッパー
---- SalesCustomMapper
---- SalesLineCustomMapper
-- ドメインモデル
--- Sales
--- SalesLine
--- SalesList
--- SalesCriteria
-- リポジトリ
--- SalesRepository
--- SalesDataSource
--- SalesEntityMapper
@endmindmap
```

## データアクセス実装手順

売上管理機能のデータアクセス部分は、以下の手順で実装されました。各ステップは特定の責務を持つコンポーネントを追加し、全体として堅牢なデータアクセス層を構築しています。

## 実装ステップ

以下は実装ステップの状態遷移を示すステートチャートです：

```plantuml
@startuml
[*] --> データベースモデルの自動生成
データベースモデルの自動生成 --> カスタムエンティティとマッパーの追加
カスタムエンティティとマッパーの追加 --> ドメインモデルの実装
ドメインモデルの実装 --> リポジトリの実装
リポジトリの実装 --> データアクセスフロー
データアクセスフロー --> [*]

state データベースモデルの自動生成 {
  [*] --> MyBatisジェネレーター実行
  MyBatisジェネレーター実行 --> モデルクラス生成
  モデルクラス生成 --> マッパーインターフェース生成
  マッパーインターフェース生成 --> [*]
}

state カスタムエンティティとマッパーの追加 {
  [*] --> カスタムエンティティ作成
  カスタムエンティティ作成 --> カスタムマッパー作成
  カスタムマッパー作成 --> [*]
}

state ドメインモデルの実装 {
  [*] --> ドメインクラス設計
  ドメインクラス設計 --> ビジネスロジック実装
  ビジネスロジック実装 --> バリデーション実装
  バリデーション実装 --> [*]
}

state リポジトリの実装 {
  [*] --> リポジトリインターフェース定義
  リポジトリインターフェース定義 --> データソース実装
  データソース実装 --> エンティティマッパー実装
  エンティティマッパー実装 --> [*]
}

state データアクセスフロー {
  [*] --> アプリケーション層との連携
  アプリケーション層との連携 --> テスト実装
  テスト実装 --> [*]
}
@enduml
```

### 1. データベースモデルの自動生成

最初のステップでは、MyBatisジェネレーターを使用してデータベーステーブルに対応するJavaモデルクラスとマッパーを自動生成します。

```plantuml
@startuml
package "自動生成モデル" {
  class 売上データ {
    +売上ID: String
    +売上日: Date
    +売上金額: BigDecimal
    +getters/setters()
  }

  class 売上データ明細 {
    +売上ID: String
    +売上明細ID: String
    +商品ID: String
    +数量: Integer
    +getters/setters()
  }

  class 売上データ明細Key {
    +売上ID: String
    +売上明細ID: String
    +getters/setters()
  }

  class 自動採番マスタ {
    +種別: String
    +年月: Date
    +自動採番値: Integer
    +getters/setters()
  }

  class 自動採番マスタKey {
    +種別: String
    +年月: Date
    +getters/setters()
  }
}

package "自動生成マッパー" {
  interface 売上データMapper {
    +insert(売上データ): int
    +selectByPrimaryKey(String): 売上データ
    +updateByPrimaryKey(売上データ): int
    +deleteByPrimaryKey(String): int
  }

  interface 売上データ明細Mapper {
    +insert(売上データ明細): int
    +selectByPrimaryKey(売上データ明細Key): 売上データ明細
    +updateByPrimaryKey(売上データ明細): int
    +deleteByPrimaryKey(売上データ明細Key): int
  }

  interface 自動採番マスタMapper {
    +insert(自動採番マスタ): int
    +selectByPrimaryKey(自動採番マスタKey): 自動採番マスタ
    +updateByPrimaryKey(自動採番マスタ): int
    +deleteByPrimaryKey(自動採番マスタKey): int
  }
}

売上データMapper ..> 売上データ
売上データ明細Mapper ..> 売上データ明細
売上データ明細Mapper ..> 売上データ明細Key
自動採番マスタMapper ..> 自動採番マスタ
自動採番マスタMapper ..> 自動採番マスタKey
@enduml
```

### 2. カスタムエンティティとマッパーの追加

次に、自動生成されたモデルを拡張するカスタムエンティティとマッパーを作成します。これにより、アプリケーション固有の要件に対応できます。

```plantuml
@startuml
package "カスタムエンティティ" {
  class SalesCustomEntity {
    +売上ID: String
    +売上日: Date
    +売上金額: BigDecimal
    +追加フィールド: Object
    +getters/setters()
  }

  class SalesLineCustomEntity {
    +売上ID: String
    +売上明細ID: String
    +商品ID: String
    +数量: Integer
    +商品名: String
    +単価: BigDecimal
    +getters/setters()
  }
}

package "カスタムマッパー" {
  interface SalesCustomMapper {
    +findById(String): SalesCustomEntity
    +findAll(): List<SalesCustomEntity>
    +findByCriteria(Map): List<SalesCustomEntity>
    +insert(SalesCustomEntity): int
    +update(SalesCustomEntity): int
    +delete(String): int
  }

  interface SalesLineCustomMapper {
    +findBySalesId(String): List<SalesLineCustomEntity>
    +insert(SalesLineCustomEntity): int
    +update(SalesLineCustomEntity): int
    +delete(String, String): int
  }
}

SalesCustomMapper ..> SalesCustomEntity
SalesLineCustomMapper ..> SalesLineCustomEntity
@enduml
```

### 3. ドメインモデルの実装

ドメインモデルは、ビジネスロジックを含むクラスで、データアクセス層とアプリケーション層の間の橋渡しをします。

```plantuml
@startuml
package "ドメインモデル" {
  class Sales {
    +salesId: String
    +salesDate: LocalDate
    +totalAmount: BigDecimal
    +salesLines: List<SalesLine>
    +calculateTotal(): BigDecimal
    +validate(): boolean
  }

  class SalesLine {
    +salesId: String
    +lineId: String
    +productId: String
    +quantity: int
    +productName: String
    +unitPrice: BigDecimal
    +calculateAmount(): BigDecimal
    +validate(): boolean
  }

  class SalesList {
    +items: List<Sales>
    +totalCount: int
    +addItem(Sales): void
    +getItems(): List<Sales>
  }

  class SalesCriteria {
    +salesId: String
    +fromDate: LocalDate
    +toDate: LocalDate
    +productId: String
    +toMap(): Map<String, Object>
  }

  Sales "1" *-- "many" SalesLine
  SalesList "1" *-- "many" Sales
}

@enduml
```

### 4. リポジトリの実装

リポジトリは、ドメインモデルとデータベースの間の変換を担当し、データアクセスの抽象化を提供します。

```plantuml
@startuml
package "リポジトリ" {
  interface SalesRepository {
    +save(Sales): Sales
    +findById(String): Optional<Sales>
    +findAll(int, int): SalesList
    +findByCriteria(SalesCriteria, int, int): SalesList
    +delete(String): void
  }

  class SalesDataSource {
    -salesCustomMapper: SalesCustomMapper
    -salesLineCustomMapper: SalesLineCustomMapper
    -salesEntityMapper: SalesEntityMapper
    +save(Sales): Sales
    +findById(String): Optional<Sales>
    +findAll(int, int): SalesList
    +findByCriteria(SalesCriteria, int, int): SalesList
    +delete(String): void
  }

  class SalesEntityMapper {
    +toEntity(Sales): SalesCustomEntity
    +toModel(SalesCustomEntity): Sales
    +toLineEntity(SalesLine): SalesLineCustomEntity
    +toLineModel(SalesLineCustomEntity): SalesLine
  }

  SalesRepository <|.. SalesDataSource
  SalesDataSource --> SalesEntityMapper
  SalesDataSource --> SalesCustomMapper
  SalesDataSource --> SalesLineCustomMapper
}

package "ドメインモデル" {
  class Sales
  class SalesLine
  class SalesList
  class SalesCriteria
}

package "カスタムマッパー" {
  interface SalesCustomMapper
  interface SalesLineCustomMapper
}

package "カスタムエンティティ" {
  class SalesCustomEntity
  class SalesLineCustomEntity
}

SalesRepository ..> Sales
SalesRepository ..> SalesList
SalesRepository ..> SalesCriteria
SalesEntityMapper ..> Sales
SalesEntityMapper ..> SalesLine
SalesEntityMapper ..> SalesCustomEntity
SalesEntityMapper ..> SalesLineCustomEntity
@enduml
```

### 5. データアクセスフロー

以下の図は、アプリケーションからデータベースまでのデータフローを示しています。

```plantuml
@startuml
actor "アプリケーション" as app
boundary "SalesRepository" as repo
control "SalesDataSource" as datasource
control "SalesEntityMapper" as mapper
entity "SalesCustomMapper" as customMapper
entity "SalesLineCustomMapper" as lineMapper
database "データベース" as db

app -> repo : save(Sales)
activate repo

repo -> datasource : save(Sales)
activate datasource

datasource -> mapper : toEntity(Sales)
activate mapper
mapper --> datasource : SalesCustomEntity
deactivate mapper

datasource -> customMapper : insert/update(SalesCustomEntity)
activate customMapper
customMapper -> db : SQL実行
db --> customMapper : 結果
customMapper --> datasource : 結果
deactivate customMapper

loop 各SalesLine
  datasource -> mapper : toLineEntity(SalesLine)
  activate mapper
  mapper --> datasource : SalesLineCustomEntity
  deactivate mapper

  datasource -> lineMapper : insert/update(SalesLineCustomEntity)
  activate lineMapper
  lineMapper -> db : SQL実行
  db --> lineMapper : 結果
  lineMapper --> datasource : 結果
  deactivate lineMapper
end

datasource -> customMapper : findById(salesId)
activate customMapper
customMapper -> db : SQL実行
db --> customMapper : SalesCustomEntity
customMapper --> datasource : SalesCustomEntity
deactivate customMapper

datasource -> lineMapper : findBySalesId(salesId)
activate lineMapper
lineMapper -> db : SQL実行
db --> lineMapper : List<SalesLineCustomEntity>
lineMapper --> datasource : List<SalesLineCustomEntity>
deactivate lineMapper

datasource -> mapper : toModel(SalesCustomEntity, List<SalesLineCustomEntity>)
activate mapper
mapper --> datasource : Sales
deactivate mapper

datasource --> repo : Sales
deactivate datasource

repo --> app : Sales
deactivate repo
@enduml
```

## データアクセス実装のポイント

1. **レイヤー分離**: データベースアクセス、ドメインモデル、アプリケーションロジックを明確に分離しています。
2. **自動生成コードの活用**: MyBatisジェネレーターを使用して基本的なCRUD操作を自動生成し、開発効率を向上させています。
3. **カスタム拡張**: 自動生成されたコードを拡張して、アプリケーション固有の要件に対応しています。
4. **ドメインモデル中心設計**: ビジネスロジックをドメインモデルに集約し、データアクセス層との依存関係を最小限に抑えています。
5. **リポジトリパターン**: データアクセスの詳細をリポジトリに隠蔽し、アプリケーションからは単純なインターフェースでアクセスできるようにしています。

## テスト戦略

データアクセス層のテストは、以下の方針で実施されています：

```plantuml
@startuml
package "テスト" {
  class SalesRepositoryTest {
    +setUp(): void
    +tearDown(): void
    +testSave_新規登録(): void
    +testSave_更新(): void
    +testFindById_存在する場合(): void
    +testFindById_存在しない場合(): void
    +testFindAll(): void
    +testFindByCriteria(): void
    +testDelete(): void
  }

  class TestDataFactoryImpl {
    +createSales(): Sales
    +createSalesLine(Sales): SalesLine
  }

  SalesRepositoryTest ..> TestDataFactoryImpl
}
@enduml
```

### テスト実装のポイント

1. **テストデータファクトリ**: テストデータの作成を一元管理し、テストコードの可読性と保守性を向上させています。
2. **CRUD操作の網羅**: 全てのリポジトリ操作（作成、読取、更新、削除）に対するテストを実装しています。
3. **エッジケースのテスト**: 存在しないIDでの検索など、エラーケースも適切にテストしています。
4. **独立したテスト環境**: 各テストは独立して実行でき、他のテストの影響を受けないように設計されています。

## 実装手順のまとめ

売上管理機能のデータアクセス部分の実装は、以下の5つのステップで行われました：

1. **データベースモデルの自動生成**: MyBatisジェネレーターを使用して基本的なモデルとマッパーを生成
2. **カスタムエンティティとマッパーの追加**: アプリケーション固有の要件に対応するための拡張
3. **ドメインモデルの実装**: ビジネスロジックを含むモデルクラスの作成
4. **リポジトリの実装**: データアクセスを抽象化するリポジトリパターンの適用
5. **テストの実装**: リポジトリの機能を検証するテストケースの作成

この実装アプローチにより、保守性が高く、拡張性のあるデータアクセス層が実現されています。
