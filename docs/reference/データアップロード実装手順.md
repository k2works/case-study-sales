---
title: 受注データアップロード実装
description: 
published: true
date: 2025-03-06T03:33:45.470Z
tags: 
editor: markdown
dateCreated: 2025-03-06T03:33:45.470Z
---

# 受注データアップロード実装

## 概要
受注データをCSVファイルからアップロードする機能の実装について説明します。

## 実装の構成

### フロントエンド実装

#### コンポーネント構成
1. **OrderUploadContainer**
   - アップロード機能のメインコンテナ
   - SalesOrderProviderコンテキストを提供
   - ローディング状態と初期データ取得を管理

2. **OrderUploadCollection**
   - アップロードボタンとアップロード結果の表示を管理
   - モーダル表示の制御
   - アップロード結果の削除機能

3. **OrderUploadModal**
   - CSVファイル選択インターフェース
   - ファイルアップロード処理
   - エラーハンドリング
   - アップロードモーダルのUI管理

4. **SalesOrderUploadResult**
   - アップロード結果の表示
   - 詳細情報の表示
   - 結果の削除機能

### バックエンド実装

#### APIエンドポイント
- **POST /api/sales-order/upload**
  - MultipartFileとしてCSVファイルを受け取る
  - アップロード処理の実行
  - 処理結果の返却

#### 主な機能
1. ファイルアップロード処理
2. CSVファイルの解析
3. データのバリデーション
4. エラーハンドリング
5. 監査ログの記録

## データフロー
1. ユーザーがCSVファイルを選択
2. フロントエンドでファイルの初期チェック
3. バックエンドへファイルをアップロード
4. バックエンドでファイル処理とバリデーション
5. 処理結果をフロントエンドへ返却
6. 結果の表示とエラーハンドリング

## エラーハンドリング
- フロントエンド
  - ファイル選択の有無チェック
  - アップロード処理中のエラー表示
  - 結果表示時のエラーメッセージ管理

- バックエンド
  - ビジネスロジックエラー
  - ファイル形式エラー
  - データバリデーションエラー

## セキュリティ
- ファイルタイプの制限（CSVのみ）
- エラーメッセージの適切な管理
- 監査ログの記録

## 実装サンプル

### フロントエンド実装サンプル

#### インターフェース定義
```typescript
interface UploadResult {
    message: string;
    details: Array<{ [key: string]: string }>;
}

interface SalesOrderContextType {
    loading: boolean;
    uploadModalIsOpen: boolean;
    uploadResults: UploadResult[];
    setError: (message: string) => void;
    setUploadModalIsOpen: (isOpen: boolean) => void;
    setUploadResults: (results: UploadResult[]) => void;
    uploadSalesOrders: (file: File) => Promise<void>;
    fetchSalesOrders: {
        load: () => Promise<void>;
    };
}
```

#### OrderUploadContainer
```tsx
import React, { useEffect } from "react";
import { SalesOrderProvider, useSalesOrderContext } from "../providers/SalesOrder";
import { OrderUploadCollection } from "./OrderUploadCollection";
import { LoadingIndicator } from "../components/LoadingIndicator";

export const OrderUploadContainer: React.FC = () => {
    const Content: React.FC = () => {
        const { loading, setError, fetchSalesOrders } = useSalesOrderContext();

        useEffect(() => {
            const loadData = async () => {
                try {
                    await fetchSalesOrders.load();
                } catch (error) {
                    setError("受注情報の取得に失敗しました");
                }
            };
            loadData();
        }, []);

        if (loading) {
            return <LoadingIndicator />;
        }
        return <OrderUploadCollection />;
    };

    return (
        <SalesOrderProvider>
            <Content />
        </SalesOrderProvider>
    );
};
```

#### SalesOrderUploadResult
```tsx
import React from "react";
import { Message } from "../components/Message";

interface Props {
    results: UploadResult[];
    onDelete: (index: number) => void;
}

export const SalesOrderUploadResult: React.FC<Props> = ({ results, onDelete }) => {
    if (!results.length) {
        return null;
    }

    const renderDetailItem = (detail: { [key: string]: string }, index: number) => (
        <div key={index} className="detail-item">
            {Object.entries(detail).map(([key, value]) => (
                <span key={key}>
                    {key}: {value}
                </span>
            ))}
        </div>
    );

    const renderResultItem = (result: UploadResult, index: number) => (
        <div key={index} className="upload-result-item">
            <Message message={result.message} />
            {result.details && (
                <div className="upload-result-details">
                    {result.details.map((detail, i) => renderDetailItem(detail, i))}
                </div>
            )}
            <button 
                className="delete-button"
                onClick={() => onDelete(index)}
            >
                削除
            </button>
        </div>
    );

    return (
        <div className="upload-result-container">
            <h3>アップロード結果</h3>
            <div className="upload-result-list">
                {results.map((result, index) => renderResultItem(result, index))}
            </div>
        </div>
    );
};
```

#### OrderUploadModal
```tsx
import React, { useState } from "react";
import Modal from "react-modal";
import { useSalesOrderContext } from "../providers/SalesOrder";

export const OrderUploadModal: React.FC = () => {
    const {
        uploadModalIsOpen,
        setUploadModalIsOpen,
        setError,
        uploadSalesOrders
    } = useSalesOrderContext();

    const [selectedFile, setSelectedFile] = useState<File | null>(null);

    const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (file) {
            if (file.type !== "text/csv") {
                setError("CSVファイルのみアップロード可能です");
                return;
            }
            setSelectedFile(file);
        }
    };

    const handleUpload = async () => {
        if (!selectedFile) {
            setError("ファイルを選択してください");
            return;
        }

        try {
            await uploadSalesOrders(selectedFile);
            setUploadModalIsOpen(false);
            setSelectedFile(null);
        } catch (error) {
            const errorMessage = error instanceof Error 
                ? error.message 
                : "アップロード中にエラーが発生しました";
            setError(errorMessage);
        }
    };

    const handleClose = () => {
        setUploadModalIsOpen(false);
        setSelectedFile(null);
    };

    return (
        <Modal
            isOpen={uploadModalIsOpen}
            onRequestClose={handleClose}
            contentLabel="受注データアップロード"
            className="upload-modal"
            overlayClassName="upload-modal-overlay"
        >
            <div className="upload-modal-content">
                <h2>受注データアップロード</h2>
                <div className="upload-form">
                    <input
                        type="file"
                        accept=".csv"
                        onChange={handleFileSelect}
                        className="file-input"
                    />
                    <div className="button-group">
                        <button
                            onClick={handleUpload}
                            disabled={!selectedFile}
                            className="upload-button"
                        >
                            アップロード
                        </button>
                        <button
                            onClick={handleClose}
                            className="cancel-button"
                        >
                            キャンセル
                        </button>
                    </div>
                </div>
            </div>
        </Modal>
    );
};
```

### バックエンド実装サンプル

#### SalesOrderService
```java
@Service
@Transactional
public class SalesOrderService {
    private final SalesOrderRepository orderRepository;
    private final CSVParser csvParser;

    public SalesOrderUploadErrorList uploadCsvFile(MultipartFile file) {
        SalesOrderUploadErrorList errorList = new SalesOrderUploadErrorList();

        try {
            List<SalesOrder> orders = csvParser.parse(file.getInputStream());

            for (SalesOrder order : orders) {
                try {
                    validateOrder(order);
                    orderRepository.save(order);
                } catch (BusinessException e) {
                    errorList.add(new SalesOrderUploadError(
                        order.getOrderNumber(),
                        e.getMessage()
                    ));
                }
            }
        } catch (IOException e) {
            throw new BusinessException("CSVファイルの読み込みに失敗しました");
        }

        return errorList;
    }

    private void validateOrder(SalesOrder order) {
        if (order.getOrderNumber() == null) {
            throw new BusinessException("注文番号は必須です");
        }
        // その他のバリデーション
    }
}
```

#### SalesOrderApiController
```java
@RestController
@RequestMapping("/api/sales-order")
@Tag(name = "受注API", description = "受注データを操作するAPI")
public class SalesOrderApiController {
    private final SalesOrderService salesOrderService;
    private final Message message;

    @Operation(summary = "受注を一括登録する")
    @PostMapping("/upload")
    @AuditAnnotation(process = ApplicationExecutionProcessType.受注登録)
    public ResponseEntity<?> upload(@RequestParam("file") MultipartFile file) {
        try {
            SalesOrderUploadErrorList result = salesOrderService.uploadCsvFile(file);
            if (result.isEmpty()) {
                return ResponseEntity.ok(new MessageResponseWithDetail(
                    message.getMessage("success.sales-order.upload"), 
                    result.asList()
                ));
            }
            return ResponseEntity.ok(new MessageResponseWithDetail(
                message.getMessage("error.sales-order.upload"), 
                result.asList()
            ));
        } catch (BusinessException e) {
            return ResponseEntity.badRequest()
                .body(new MessageResponse(e.getMessage()));
        }
    }
}
```

### CSVファイルフォーマット

#### ヘッダー定義
| 項目名 | 形式 | 必須 | 説明 |
|--------|------|------|------|
| 注文番号 | 文字列(10) | ○ | 注文を一意に識別する番号。例: O-2023001 |
| 注文日 | 日付(YYYY-MM-DD) | ○ | 注文が発生した日付 |
| 部門コード | 文字列(4) | ○ | 注文を担当する部門のコード |
| 得意先コード | 文字列(4) | ○ | 得意先を識別するコード |
| 得意先支店番号 | 文字列(4) | ○ | 得意先の支店を識別する番号 |
| 担当者コード | 文字列(4) | ○ | 担当者を識別するコード |
| 希望納期 | 日付(YYYY-MM-DD) | ○ | 顧客が希望する納期 |
| 得意先注文番号 | 文字列(10) | - | 得意先側の注文管理番号 |
| 倉庫コード | 文字列(4) | ○ | 出荷元の倉庫を識別するコード |
| 合計注文金額 | 数値 | ○ | 注文の合計金額（税抜） |

#### バリデーションルール
1. すべての必須項目が入力されていること
2. 日付形式が正しいこと（YYYY-MM-DD）
3. 注文番号が一意であること
4. 合計注文金額が0より大きいこと
5. 各コードが既存のマスタに存在すること

#### サンプルデータ
```csv
注文番号,注文日,部門コード,得意先コード,得意先支店番号,担当者コード,希望納期,得意先注文番号,倉庫コード,合計注文金額
O-2023001,2023-05-01,D001,C001,B001,E001,2023-05-10,CO-001,W001,50000
O-2023002,2023-05-02,D002,C002,B001,E002,2023-05-15,CO-002,W001,75000
O-2023003,2023-05-03,D001,C003,B002,E001,2023-05-20,CO-003,W002,100000
```

#### エラー例と対処方法
1. 重複した注文番号
```csv
O-2023001,2023-05-01,D001,C001,B001,E001,2023-05-10,CO-001,W001,50000
O-2023001,2023-05-02,D002,C002,B001,E002,2023-05-15,CO-002,W001,75000  # エラー: 注文番号が重複
```

2. 不正な日付形式
```csv
O-2023004,2023/05/01,D001,C001,B001,E001,2023-05-10,CO-001,W001,50000  # エラー: 日付形式が不正
```

3. 存在しない部門コード
```csv
O-2023005,2023-05-01,D999,C001,B001,E001,2023-05-10,CO-001,W001,50000  # エラー: 存在しない部門コード
```

## 今後の改善点
1. ファイルサイズの制限の実装
2. プログレスバーの追加
3. 一括処理の非同期化
4. エラー時のリトライ機能
